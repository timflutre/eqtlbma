\input texinfo   @c -*-texinfo-*-
@finalout @comment{prevent TeX from printing a black rectangle beside overful hbox}
@c %**start of header
@setfilename manual_eqtlbma.info
@include version.texi
@settitle Manual for eQtlBma @value{VERSION}
@syncodeindex pg cp
@c %**end of header

@c to have proper quotes in code blocks http://www.gnu.org/software/texinfo/manual/texinfo/texinfo.html#g_t_0040url
@codequoteundirected on
@codequotebacktick on

@copying
This manual is for eQtlBma (version @value{VERSION}, @value{UPDATED}),
which implements Bayesian methods for eQTL detection.

Copyright @copyright{} 2012-2015 Timoth@'ee Flutre, Xiaoquan Wen.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory Texinfo documentation system
@direntry
* sample: (sample)Invoking sample.
@end direntry

@titlepage
@title eQtlBma
@subtitle for version @value{VERSION}, @value{UPDATED}
@author T. Flutre and X. Wen (@email{eqtlbma-users@@googlegroups.com})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top eQtlBma

This manual is for eQtlBma (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Overview::
* Tutorial::
* Computing Bayes factors::
* Fitting the hierarchical model::
* Computing the posteriors::
* For developers::
* Frequently asked questions::
* GNU Free Documentation License::
* Index::
@end menu


@node Overview
@chapter Overview

In genetics, ``QTL'' stands for quantitative trait locus.
It corresponds to a genotype-phenotype relationship for which a proportion of the variation in phenotype can be ascribed to deviation of the genotype from the mean genetic value (Lewontin, 2006).
For the moment, this package focuses on the case where genotypes come from single nucleotide polymorphisms (SNPs) 
and phenotypes are gene expression levels, thus explaining the ``e'' in ``eQTL'' (but other phenotypes can be handled as well).

This package provides implementations of Bayesian methods with two goals in mind:
@itemize
@item
to detect eQTLs;
@item
to interpret them.
@end itemize

The implemented methods allow to jointly analyze data sets from multiple subgroups.
Here @emph{subgroups} can be different tissues, populations, platforms, treatments, etc.
Currently three main tools are available:
@itemize
@item
@command{eqtlbma_bf} can compute summary statistics in each subgroup, 
@url{https://en.wikipedia.org/wiki/Bayes_factor,Bayes factors} for the joint analysis using default hyperparameters, 
as well as perform permutations at the gene-level;
@item
@command{eqtlbma_hm} can fit the hierarchical model via an EM algorithm (maximum likelihood),
and thus provide ``empirical Bayes'' estimates of hyperparameters;
@item
@command{eqtlbma_avg_bfs} can perform Bayesian model averaging 
using the raw Bayes factors from @command{eqtlbma_bf} weighted by the estimates from @command{eqtlbma_hm}, 
and then compute various posterior probabilities of interest.
@end itemize

The details of the model are freely available online in the @url{http://dx.doi.org/10.1371/journal.pgen.1003486,article} by Flutre @emph{et al} (PLoS Genetics, 2013).
See also Wen's @url{http://stephenslab.uchicago.edu/MSpapers/WenThesis.pdf,PhD thesis} (2011), the @url{http://dx.doi.org/10.1214/13-AOAS695,article} by Wen & Stephens (Annals of Applied Statistics, 2014) and the @url{http://dx.doi.org/10.1111/biom.12112,article} by Wen (Biometrics, 2014).

To install the package, it is recommended to read this @url{https://github.com/timflutre/eqtlbma/wiki,web page}.
In case of trouble during installation or usage of the package, questions can be posted to this @url{https://groups.google.com/forum/#!forum/eqtlbma-users,mailing list}.

@c=============================================================================

@node Tutorial
@chapter Tutorial

@cindex tutorial

The @command{eqtlbma} package implements a hierarchical model based on multivariate linear regressions in a Bayesian framework fitted via an EM algorithm (``empirical Bayes'').
The package can be used to answer numerous questions (see articles referenced in the ``Overview'' section) and has a fairly large set of options (see next sections).
As such, it is quite general and thus powerful, yet can be overwhelming at first for users, even if most options are set by default.
As concrete example, this tutorial hence describes a whole analysis aiming at finding eQTLs by jointly analyzing multiple tissues.
We hope that it provides a clear-enough case that any user can then adapt to its own need.

As you can read this manual, we assume that the @command{eqtlbma} package was successfully installed on your machine.
You should thus have several new programs in your @url{https://en.wikipedia.org/wiki/PATH_%28variable%29,PATH}: @command{eqtlbma_bf}, @command{eqtlbma_hm} and @command{eqtlbma_avg_bfs}, as well as @command{tutorial_eqtlbma.R}.
Following the tradition, all programs in the @command{eqtlbma} package show a help message with options @option{-h} and @option{--help}.

If you are not accustomed to:
@itemize
@item
running command lines in a terminal (that is, without graphical interface), you can learn more @url{http://en.flossmanuals.net/command-line/index/,here};
@item
text manipulation on UNIX-based systems, you can learn more @url{http://www.ibm.com/developerworks/aix/library/au-unixtext/index.html,here};
@item
bash scripting, you can learn more @url{http://www.tldp.org/LDP/abs/html/,there};
@end itemize
but you should be able to follow the tutorial without extensive knowledge of all this.

@sp 1

Let's start by creating a directory for this tutorial:
@verbatim
cd $HOME
mkdir tutorial_eqtlbma
cd tutorial_eqtlbma
@end verbatim

Instead of using ``real'' data, we will simulate ``realistic'' data using the widely-used free software @url{http://www.r-project.org/,R} (version >= 3.0).
Let's imagine that N=200 individuals are sampled.
For each, mRNA levels are measured for G=1000 genes in S=3 tissues.
Moreover, each gene has on average 50 SNPs in @emph{cis}, for which we know the genotypes.

@verbatim
tutorial_eqtlbma.R \
--pkg ~/src/eqtlbma \
>& stdout_tutorial_eqtlbma.txt &
@end verbatim
where ``~/src/eqtlbma'' is supposed to be the path corresponding to where the package is present (you may have to adapt it to your particular situation).

You can track the progress of the program by looking into the file ``stdout_tutorial_eqtlbma.txt''.
Simulating data with R can be slow, but you can use option @option{--cores} to speed this up (adapt to the number of cores available on your machine).
Note also that the script ``tutorial_eqtlbma.R'' contains many options one can play with to make the data more realistic (e.g. having SNPs with low MAF via option @option{--rare}).

As you can now see in the directory, several files were generated in such formats that it should be easy for you to prepare your own data similarly.

We can now launch the first program, @command{eqtlbma_bf}, to compute the Bayes factors assessing the support in the data for each gene-SNP pair being an eQTL:

@verbatim
eqtlbma_bf \
--geno list_genotypes.txt \
--scoord snp_coords.bed.gz \
--exp list_explevels.txt \
--gcoord gene_coords.bed.gz \
--anchor TSS \
--cis 1000 \
--out out_eqtlbma \
--analys join \
--covar list_covariates.txt \
--gridL grid_phi2_oma2_general.txt \
--gridS grid_phi2_oma2_with-configs.txt \
--bfs all \
--error mvlr \
>& stdout_eqtlbma_bf.txt &
@end verbatim

You can track the progress of the program by looking into the file ``stdout_eqtlbma_bf.txt''.
Upon completion, the output file ``out_eqtlbma_l10abfs_raw.txt.gz'' contains the Bayes factor for each configuration of each gene-SNP pair (in rows) and each grid point (in columns):
@verbatim
zcat out_eqtlbma_l10abfs_raw.txt.gz | head
@end verbatim

We can now feed this file to the second program, @command{eqtlbma_hm}, to fit the hierarchical model with an EM algorithm and get maximum-likelihood estimates of hyper-parameters, most importantly the configuration probabilities:

@verbatim
eqtlbma_hm \
--data "out_eqtlbma_l10abfs_raw.txt.gz" \
--nsubgrp 3 \
--dim 7 \
--ngrid 10 \
--out out_eqtlbma_hm.txt.gz \
>& stdout_eqtlbma_hm.txt &
@end verbatim

You can track the progress of the program by looking into the file ``stdout_eqtlbma_bf.txt''.
Upon completion, the output file ``out_eqtlbma_hm.txt.gz'' contains the estimates as meta-data (commented lines starting with a hashtag ``#'').

We now need to extract these estimates before calculating the posterior probabilities of interest:

@verbatim
zcat out_eqtlbma_hm.txt.gz | grep "#grid" | cut -f2 > grid_weights.txt
zcat out_eqtlbma_hm.txt.gz | grep "#config" \
| awk '{split($1,a,"."); print a[2]"\t"$2}' > config_weights.txt
@end verbatim

Finally we can launch the third program, @command{eqtlbma_avg_bfs}.
To obtain the posterior probabilities, we need an estimate of the probability for a gene to have no eQTL in any tissue, @math{\pi_0}.
As this quantity is hard to estimate accurately with the EM algorithm, we usually perform permutations using @command{eqtlbma_bf} (see below).
But for now, as this can take some time, we will use its true value, as indicated in the output file ``stdout_tutorial_eqtlbma.txt''.

@verbatim
eqtlbma_avg_bfs \
--in "out_eqtlbma_l10abfs_raw.txt.gz" \
--gwts grid_weights.txt \
--nsubgrp 3 \
--dim 7 \
--cwts config_weights.txt \
--save post \
--pi0 0.3 \
--post a+b+c+d \
--bestdim \
--alldim \
--out out_eqtlbma_avg_bfs.txt.gz \
>& stdout_eqtlbma_avg_bfs.txt &
@end verbatim

Upon completion, the output file ``out_eqtlbma_avg_bfs.txt.gz'' contains the posterior probability for the gene to have an eQTL in at least one tissue (column 3), the posterior for a SNP to be ``the'' eQTL (column 4), the posterior for the eQTL to be active in a given tissue (columns 6-8) and the posterior for the eQTL to be active in a given configuration (columns 9-15).

You should now be able to perform a similar analysis with your own data.
Of course, you will surely need more details.
See the next sections about input and output formats, program options, parallelization, etc.

@sp 2

The remaining of this section briefly describes how to estimate @math{\pi_0}, via gene-level p-values obtained by permutations followed by the @url{http://www.bioconductor.org/packages/release/bioc/html/qvalue.html,qvalue} package, or via the EBF/QBF procedures proposed in @url{http://arxiv.org/abs/1311.3981,this preprint} by Wen (2013).

As permutations take time, we will run them in parallel, which hence requires to prepare the data in batches (@pxref{Frequently asked questions} for more explanations).

First we keep only the transcription start site (TSS) of each gene:
@verbatim
zcat gene_coords.bed.gz \
| awk 'BEGIN{OFS="\t"} \
{printf "%s\t%s\t%s", $1,$2,$2+1; \
for(i=4;i<=NF;++i)printf "\t%s", $i; printf "\n"}' \
| gzip > gene_coords_TSS.bed.gz
@end verbatim

Then we split the genes in batches:
@verbatim
nbBatches="100"; rm -rf lists_genes; mkdir lists_genes; cd lists_genes; \
zcat ../gene_coords_TSS.bed.gz | split \
-l $(echo "scale=0; $(zcat ../gene_coords_TSS.bed.gz | wc -l)/${nbBatches}" | bc -l) \
--suffix-length=3 --numeric-suffixes=1 --additional-suffix=.bed \
--filter='gzip > $FILE.gz' - list_genes_; cd ..
@end verbatim

Then we make a file containing all @emph{cis} SNPs per batch of genes:
@verbatim
rm -rf lists_snps; mkdir lists_snps; \
seq -w 1 $(ls lists_genes/* | wc -l) | \
parallel 'i={}; bedtools window -w 1000 \
-a lists_genes/list_genes_${i}.bed.gz \
-b snp_coords.bed.gz | \
cut -f10 | sort -V | uniq | gzip > lists_snps/list_snps_${i}.txt.gz'
@end verbatim

Finally we draw one seed per batch (to make permutations reproducible):
@verbatim
nbSeeds=$(ls lists_genes/* | wc -l); \
echo "set.seed(1859); x <- sample.int(n=1000000, size=${nbSeeds}); \
write(x, gzfile(\"list_seeds.txt.gz\"), 1)" \
| R --vanilla --quiet
@end verbatim

@sp 1

For the gene-level p-values, we can now perform permutations in parallel (note also in the command-line below that each batch is run on 4 threads):
@verbatim
echo "eqtlbma_bf_parallel.bash --p2b ~/bin/eqtlbma_bf --geneD lists_genes \
--snpD lists_snps --seedF list_seeds.txt.gz --geno list_genotypes.txt \
--scoord snp_coords.bed.gz --exp list_explevels.txt --anchor TSS --cis 1000 \
--out out_eqtlbma --analys join --covar list_covariates.txt \
--gridL grid_phi2_oma2_general.txt --gridS grid_phi2_oma2_with-configs.txt \
--bfs all --error mvlr --nperm 10000 --trick 2 --tricut 10 --pbf all --thread 4" \
| qsub -cwd -j y -V -l h_vmem=8g -N stdout_eqtlbma_bf-perm -t 1-100 -pe simple_pe 4
@end verbatim

Once all jobs are finished, let us check that they all ran successfully:
@verbatim
ls stdout_eqtlbma_bf-perm.o*.* | while read f; do \
if [ $(grep -c "END" $f) != 2 ]; then echo $f; fi; done
@end verbatim

We can then open R and estimate @math{\pi_0} with the @command{qvalue} package:
@smallformat
@verbatim
setwd("~/tutorial_eqtlbma")
f <- Sys.glob("out_eqtlbma_[0-9][0-9][0-9]_joinPermPvals.txt.gz")
d <- do.call(rbind, lapply(f, function(fi){
  read.table(fi, header=TRUE, stringsAsFactor=FALSE)
}))
hist(d$join.perm.pval, xlim=c(0,1), breaks=100)
library(qvalue)
qobj <- qvalue(p=d$join.perm.pval, fdr.level=0.05, robust=TRUE, pi0.method="smoother")
qobj$pi0
called.nulls.pval <- ! qobj$significant
@end verbatim
@end smallformat

We can now use this estimate of @math{\pi_0} to compute the various posterior probabilities of interest with @command{eqtlbma_avg_bfs} as shown above.

@sp 1

For the EBF procedure, we only need the gene-level Bayes factors averaged over the grid and configuration weights (estimated via the EM algorithm):
@verbatim
eqtlbma_avg_bfs \
--in "out_eqtlbma_l10abfs_raw.txt.gz" \
--gwts grid_weights.txt \
--nsubgrp 3 --dim 7 \
--cwts config_weights.txt \
--save bf \
--out out_eqtlbma_avg_bfs_genes.txt.gz \
>& stdout_eqtlbma_avg_bfs_genes.txt &
@end verbatim

Once we have these Bayes factors, we can estimate @math{\pi_0} with the EBF procedure implemented in an R file in the @command{eqtlbma} package:
@smallformat
@verbatim
gene.bfs <- read.table("out_eqtlbma_avg_bfs_genes.txt.gz", header=TRUE)
source("~/src/eqtlbma/scripts/utils_eqtlbma.R")
pi0.ebf <- estimatePi0WithEbf(log10.bfs=gene.bfs$gene.log10.bf[!duplicated(gene.bfs$gene)],
                              verbose=1)
called.nulls.ebf <- ! controlBayesFdr(log10.bfs=gene.bfs$gene.log10.bf[!duplicated(gene.bfs$gene)],
                                      pi0=pi0.ebf, fdr.level=0.05, verbose=1)
@end verbatim
@end smallformat

We can now use this estimate of @math{\pi_0} to compute the various posterior probabilities of interest with @command{eqtlbma_avg_bfs} as shown above.

@sp 1

For the QBF procedure, the @command{eqtlbma} package performs permutations to get the median Bayes factors under the null, but much less than to get p-values:
@verbatim
echo "eqtlbma_bf_parallel.bash --p2b ~/bin/eqtlbma_bf --geneD lists_genes \
--snpD lists_snps --seedF list_seeds.txt.gz --geno list_genotypes.txt \
--scoord snp_coords.bed.gz --exp list_explevels.txt --anchor TSS --cis 1000 \
--out out_eqtlbma_qbf --analys join --covar list_covariates.txt \
--gridL grid_phi2_oma2_general.txt --gridS grid_phi2_oma2_with-configs.txt \
--bfs all --error mvlr --nperm 250 --pbf all --thread 4" \
| qsub -cwd -j y -V -l h_vmem=8g -N stdout_eqtlbma_bf-permed -t 1-100 -pe simple_pe 4
@end verbatim

We check that all jobs ran successfully:
@verbatim
ls stdout_eqtlbma_bf-permed.o*.* | while read f; do \
if [ $(grep -c "END" $f) != 2 ]; then echo $f; fi; done
@end verbatim

Once we have these median Bayes factors, we can estimate @math{\pi_0} with the QBF procedure implemented in an R file in the @command{eqtlbma} package:
@smallformat
@verbatim
f <- Sys.glob("out_eqtlbma_qbf_[0-9][0-9][0-9]_joinPermPvals.txt.gz")
perms.qbf <- do.call(rbind, lapply(f, function(fi){
  read.table(fi, header=TRUE, stringsAsFactor=FALSE)
}))
source("~/src/eqtlbma/scripts/utils_eqtlbma.R")
pi0.qbf <- estimatePi0WithQbf(log10.bfs=perms.qbf$med.perm.log10.bf[!duplicated(perms.qbf$gene)],
                              gamma=0.5, verbose=1)
called.nulls.qbf <- ! controlBayesFdr(log10.bfs=gene.bfs$gene.log10.bf[!duplicated(gene.bfs$gene)],
                                      pi0=pi0.qbf, fdr.level=0.05, verbose=1)
@end verbatim
@end smallformat

We can now use this estimate of @math{\pi_0} to compute the various posterior probabilities of interest with @command{eqtlbma_avg_bfs} as shown above.

@sp 1

As shown in the preprint of Wen (2013), the EBF/QBF procedures are much less computationally intensive than obtaining p-values by permutations, hence being tractable even for large datasets, while still conservatively controlling a given FDR level.

As a quick example, the table below summarizes results for the tutorial data obtained with all commands listed above, for which the true @math{\pi_0} is 0.287, the true number of eGenes is 713 and the FDR is controlled at 0.05:

@multitable @columnfractions .3 .175 .175 .175 .175
@headitem Method @tab @math{\pi_0} (estim.) @tab eGenes (#) @tab FDP @tab FNP
@item p-values (with trick) @tab 0.439 @tab 602 @tab 0.0266 @tab 0.3191
@item p-values (without trick) @tab 0.394 @tab 609 @tab 0.0328 @tab 0.3171
@item EBF @tab 0.476 @tab 617 @tab 0.0324 @tab 0.3029
@item QBF @tab 0.400 @tab 627 @tab 0.0447 @tab 0.3056
@end multitable

@c=============================================================================

@node Computing Bayes factors
@chapter Computing Bayes factors

@cindex Bayes factors
@cindex eqtlbma_bf

Typing @command{eqtlbma_bf --help} or @command{eqtlbma_bf -h} gives the list of options.
As the help message is long, we may prefer to type @command{eqtlbma_bf -h | less} instead.

Most importantly, for each gene-SNP pair, the @command{eqtlbma_bf} program can compute the Bayes factors (for each configuration and each grid point).
Such Bayes factors can be computed from ``raw'' data or from ``summary statistics'' per subgroup.
The @command{eqtlbma_bf} program can also perform permutations at the gene-level.

@section Inputs and options

@cindex inputs eqtlbma_bf
@cindex options eqtlbma_bf

@subsection Genotypes

The option @option{--geno} requires a file as argument.
This file has two columns separated by a space or a tabulation, and one line per subgroup.
The first column is the identifier of the subgroup.
The second column is the path to the file containing the genotypes for this subgroup.
Here is an example:
@verbatim
Fibroblasts /data/genotypes.vcf.gz
LCLs /data/genotypes.vcf.gz
T-cells /data/genotypes.vcf.gz
@end verbatim

As you can see, the genotypes can all be in the same file, useful for instance if subgroups share some or all individuals.
But of course it is also possible to have one file per subgroup.

If you want to skip one subgroup, simply add a hashtag at the begining of the line, like this:
@verbatim
#Fibroblasts /data/genotypes.vcf.gz
@end verbatim

The files containing the genotypes can be in three possible formats.
Even though these formats can handle genetic variants other than SNPs,
we focus here on SNPs.
Moreover, for each format, the names of the individuals have to be indicated 
and they need to be the same as in the files containing the gene expression levels (see next section).

SNPs with missing genotypes are skipped with a warning.
It is therefore advised to impute them first with packages such as @url{http://mathgen.stats.ox.ac.uk/impute/impute_v2.html,IMPUTE2} or @url{http://stephenslab.uchicago.edu/blimp/index.html,BLIMP}.

The program @command{eqtlbma_bf} recognizes the original VCF format (it only requires the ``GT'' keyword in the FORMAT column).
See the specificiations on the website of the 1000 Genomes project @url{http://www.1000genomes.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-41,here}.

The program @command{eqtlbma_bf} can also handle a format very similar to the genotype format used by the IMPUTE program.
The exact specification of this format is described @url{http://www.stats.ox.ac.uk/~marchini/software/gwas/file_format.html,here}.
The only difference is that a header line is required.
Here is an example:
@verbatim
chr name coord a1 a2 <ind1>_a1a1 <ind1>_a1a2 <ind1>_a2a2 <ind2>_a1a1 ...
@end verbatim
where the ``<ind1>'''s have to be replaced by the name of the individuals in the given data set.

Finally, the program @command{eqtlbma_bf} also reads genotypes as allele dose, that is 0, 1, 2 or NA.
This format is also read by the R package @url{http://dx.doi.org/10.1093/bioinformatics/bts163,MatrixEQTL}.
Here is an example:
@verbatim
id ind1 ind2 ind3 ...
snp1 0 2 1 ...
snp2 0 1 0 ...
...
@end verbatim

The VCF and IMPUTE-like formats contain information about SNP coordinates, thus they should not be used with @option{--scoord}.
However, the allele-dose format do need the option @option{--scoord},
followed by a file containing the SNP coordinate in the @url{http://genome.ucsc.edu/FAQ/FAQformat.html,BED format}.
This means that the start coordinate is 0-based, there is no header line and the column separator is a tabulation.

When parallelizing an analyzis over genes, we may want to only load the SNPs in @emph{cis} of the genes in the given job.
In order to speed-up this, the eQtlBma package uses some code from @url{https://github.com/samtools/tabix,TABIX} described in @url{http://dx.doi.org/10.1093/bioinformatics/btq671,this paper} (Li, 2011).
More specifically, if a bgzip-compressed BED file named ``snp_coords.bed.gz'' is given to the option @option{--scoord},
the code will look for a tabix-indexed file named ``snp_coords.bed.gz.tbi'' 
and use it to only load the SNPs in @emph{cis} of the genes specified by the option @option{--gcoord}.
If the index file is not present, all SNPs will be loaded which will be slower and use more memory.
@xref{Frequently asked questions} to know how to build the index for the BED file.

The option @option{--maf} allows to skip SNPs if their minor allele frequency in the genotype file is below a given threshold, for instance 0.05.

The option @option{--covar} requires a file as argument.
This file has two columns separated by a space or a tabulation, and one line per subgroup.
The first column is the identifier of the subgroup.
The second column is the path to the file containing the covariates for this subgroup.

Each covariate file has to be in the following format:
@verbatim
id ind1 ind2 ...
covar1 0.32 0.11 ...
covar2 -1.0 0.8 ...
...
@end verbatim
Note that this format is also read by the R package MatrixEQTL.
Here also, no missing covariate is allowed.
However, in eQtlBma, the covariates are assumed to be additive.
This is fine for continuous covariates (say, principal components to account for some population structure) or binary (say, gender).
However, if the covariates are categorical, we recommend to regress them out beforehand, for instance by using R where you can encode them as @url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/factor.html,factors}.


@subsection Expression levels

As for the option @option{--geno}, the option @option{--exp} requires a file as argument.
This file has two columns separated by a space or a tabulation, and one line per subgroup.
The first column is the identifier of the subgroup.
The second column is the path to the file containing the genotypes for this subgroup.
Here is an example:
@verbatim
Fibroblasts /data/phenotypes_Fibroblasts.txt.gz
LCLs /data/phenotypes_LCLs.txt.gz
T-cells /data/phenotypes_T-cells.txt.gz
@end verbatim

The program @command{eqtlbma_bf} uses the term ``gene'' as the generic term for
the entities for which we have measurements.
Besides genes, they could be exons, transcripts, proteins, metabolites, etc, 
but we stick to genes in this manual.
(Note also that the program implements a model with a specific prior 
meaningful for genes but which may not be appropriate for some other entities.)

The actual files containing the expression levels have the following format:
@verbatim
ind1 ind2 ind3 ...
gene1 2.0495 1.0947 1.9924 ...
gene2 0.1928 -0.873 0.5284 ...
...
@end verbatim
Here again, this format is read by the R package MatrixEQTL.

More importantly, the sample identifiers should be the same between genotype and expression files.
The order of the columns is not important, but the fact that the identifiers 
should be the same between files is an effort to avoid forgetting which column 
correspond to which sample, as can easy happen when data sets are shared between collaborators.

Note that, starting with version 1.3, missing expression levels are allowed.
They should be encoded with ``NA'', ``na'', ``NaN'' or ``nan''.
Missing data can arise from various reasons.
The consequence can be that given individuals are completely missing from some subgroups,
or only some genes from given individuals are missing in some subgroups.
If the individuals are different in each subgroup, then one doesn't need to allow the errors
in the multivariate regression to be correlated, and there is no problem.
However, if the individuals are partially overlapping between subgroups, 
we need to explicitly handle the missing data.
In such a case, we assume that the data are ``missing at random'', that is, 
the fact that a gene expression level is missing is a priori not associated 
with the genotypes at any SNP.
Then, the only issue is about estimating the covariance between the errors in 
each pair of subgroups (off-diagonal elements of the covariance matrix).
Our solution is straightforward: for a given pair of subgroup, we simply use 
the individuals present in these two subgroups.

As the files with phenotypes don't contain the gene coordinates, we also need to use the option
@option{--gcoord} to specify gene coordinates in the @url{http://genome.ucsc.edu/FAQ/FAQformat.html,BED format}.
Genes with no coordinates will be skipped (useful when launching the program in parallel, see below).

The option @option{--qnorm} allows the program to transform the expression 
level of each gene into the quantiles of a standard Normal distribution.
This is done just before performing the linear regressions.
Otherwise, an FAQ entry at the end of this document indicates how to do this beforehand in R (better because ties are randomly broken in the R code).


@subsection @emph{Cis} region

The @command{eqtlbma_bf} program focuses on detecting associations between SNPs and genes,
restricting itself to SNPs in a @emph{cis} candidate region of each gene.
@c The option @option{--anchor} allows to specify the boundary(ies) of this region,
@c with ``TSS'' for ``transcription start site'', ``TES'' for ``transcription end site'' and
@c ``TSS+TES'' for both.
The option @option{--cis} precises the length of half of the @emph{cis} region (i.e. the radius), in base pairs.

@c As an example, @option{--anchor TSS --cis 100000} means that, for each gene, 
@c we will test all SNPs falling in the interval [-100kb,+100kb] centered on the
@c the start coordinate of the given gene as determined from the BED file given to option @option{--gcoord}.

Following the convention in @url{http://code.google.com/p/bedtools/,BEDTools}, 
the definition of the @emph{cis} region uses <= and >= instead of < and >.

Note that, for the moment, only the first four columns of the BED file are used, 
assuming that the start and end coordinates correspond to the TSS.
At some point we will have to improve the code to also handle the strand, if specified.


@subsection Possible analyzes

The option @option{--out} requires a character string which will be used as a prefix to name the output files.
Moreover, all output files are directly written in a compressed mode using @url{http://www.zlib.net/,zlib}.
That is, all output files are readable by @command{gzip} and @command{zcat}.
The option @option{--wrtsize} controls the amount of output at a time.
It requires a positive integer, which specifies how many genes to analyze before their results are written to disk and released from memory.
This option prevents @command{eqtlbma_bf} from using too much memory if there are large number of cis SNPs per gene.

The program @command{eqtlbma_bf} can perform several analyzes.
The option @option{--analys sep} means that the gene-SNP pairs will be tested for association using the subgroup-by-subgroup analysis (``separate'' analysis).
The option @option{--analys join} means that the gene-SNP pairs will be tested for association using all subgroups jointly, which is more powerful in the context of eQTL studies, as shown in Flutre @emph{et al}.

At the beginning of each step, summary statistics are computed in each subgroup 
(estimates of effect sizes, standard errors, p-values, etc).
If the option @option{--outss} is not specified, the summary statistics won't be saved.
This can be useful in some cases: for instance, when we want to run a set of jobs with @option{--permsep 1} 
and another set of jobs with @option{--permsep 2}, both sets of jobs in the same directory.
We would typically use option @option{--outss} with the first set of jobs but not with the second,
otherwise both sets of jobs may overwrite each other's files.
However, note that we need the summary stats per subgroup if we want to later make meta-analysis-like @url{https://en.wikipedia.org/wiki/Forest_plot,forest plots}.

If the option @option{--outw} is not specified, only the raw Bayes factors will be saved,
as they are needed to fit the hierarchical model with the @command{eqtlbma_hm} program.
If it's specificed, the program will also save the Bayes factors per configuration, averaged over the grid using uniformly equal weights.

When using option @option{--analys join}, we need to specify the options @option{--gridL} and @option{--gridS},
along with two files containing the grids over which the Bayes factors are averaged.
A grid has two columns, 
the first contains values of @math{\phi^2} (prior variance of the standardized effects @math{b_s}'s in each subgroup) 
and the second values of @math{\omega^2} (prior variance of the average standardized effect @math{\bar{b}}).

The option @option{--gridL} specifies a ``large'' grid.
It is typically used for meta-analysis (see Wen & Stephens, AoAS 2014),
or for the BMAlite analysis (see Flutre @emph{et al}, 2013).
The option @option{--gridS} specifies a ``small'' grid used with configurations (see Flutre @emph{et al}).
An FAQ entry below shows how to produce such files in R.

The option @option{--bfs} allows to specify which Bayes factors we want to compute.
The acronym ``abf'' is used to mean ``approximated Bayes factor'' because the Bayes factor
can't be calculated analytically and therefore has to be approximated.
The article from Wen & Stephens in AoAS 2014 detailed different ways to do that.
However, @option{--bfs} only implements the ABF with the ES model using Laplace's method.
Moreover, the small sample size correction is also implemented (Wen & Stephens, AoAs 2014, appendix C).

Specifying @option{--bfs gen} computes the ``general'' BF 
corresponding to the consistent configuration using the large grid.
This ``general'' BF is useful in a meta-analysis setting, and fixed-effect 
and maximum-heterogeneity BFs are also calculated (see Wen & Stephens, AoAS 2014).

Specifying @option{--bfs sin} also computes the BF for each singleton, 
that is for configurations (100), (010) and (001) if there are 3 subgroups.
Also, the average of the ``general'' BF and each ``singleton'' BF is reported under the name ``abf.gen.sin''.
It corresponds to ``BF_BMAlite'' in Flutre @emph{et al}.

Finally, specifying @option{--bfs all} computes the BF for each configuration.
The weighted average of all these BFs is also reported under the name ``abf.all''.
It corresponds to ``BF_BMA'' in Flutre @emph{et al}.
Using @option{--bfs all} can be too costly when the number of subgroups exceeds 15 or 20.

The model implemented in this package is based on a linear regression, and there are several ways of
specifying the variance-covariance matrix of the errors.
If the subgroups contain different individuals, we can choose @option{--error uvlr}, for univariate linear regression, as in Wen & Stephens, AoAS 2014.
It assumes the errors are not correlated between subgroups, and thus only estimates the variances.
If the subgroups contain exactly the same individuals, we can choose @option{--error mvlr}, for multivariate linear regression, as in Wen, Biometrics 2014.
It assumes the errors are correlated between subgroups, and thus estimates the full variance-covariance matrix.
If the subgroups contain some individuals in common and some not, we can choose @option{--error hybrid}.
It works as @option{--error mvlr}, except that each error covariance between any two subgroups is estimated using only individuals common to these subgroups.

When using @option{--error mvlr} or @option{--error hybrid}, the option @option{--fiterr} is set by default at 0.5.
See Wen, Biometrics 2014, for the rationale.
Also, with @option{--error mvlr}, the summary statistics per subgroup are not exported (in theory it's possible but the current code doesn't allow it easily).
So in this case, if we want to make forest plots, we will have to also launch @command{eqtlbma_bf} with option @option{--error uvlr}.


@subsection Summary statistics

Sometimes it is not possible to access the ``raw'' data, as in human genetics where genotypes often are confidential.
In such a case, @command{eqtlbma_bf} can still computes the Bayes factors using summary statistics.
Note that, for the moment, it only works with @option{--error uvlr}.

The option @option{--inss} requires a file as argument.
This file has two columns separated by a space or a tabulation, and one line per subgroup.
The first column is the identifier of the subgroup.
The second column is the path to the file containing the summary statistics for this subgroup.
Here is an example:
@verbatim
Fibroblasts /results/sstats_Fibroblasts.txt.gz
LCLs /results/sstats_LCLs.txt.gz
T-cells /results/sstats_T-cells.txt.gz
@end verbatim

The actual files containing the summary statistics need a header line containing the following words: gene, snp, n, sigmahat, betahat.geno and sebetahat.geno (in any order).
Let's consider the following linear regression of mRNA levels at gene @math{g} in subgroup @math{s} on the genotypes at SNP @math{p}: @math{\forall i \in \{1,\ldots,n\}, \; y_{gsi} = \mu_{gs} + \beta_{gps} x_{psi} + \epsilon_{gpsi}} with @math{\epsilon_{gpsi} \sim N(0,\sigma_{gps}^2)}.
As a result, the @emph{n} column should contain the number of samples in the linear regression; the @emph{sigmahat} column should contain the estimate of the standard deviation of the errors, @math{\sigma_{gps}}; the @emph{betahat.geno} column should contain the estimate of the effect size of the genotype, @math{\beta_{gps}}; and the @emph{sebetahat.geno} column should contain the standard error of this estimate.
In the end, the file should have the following format:
@verbatim
gene    snp     n       sigmahat        betahat.geno    sebetahat.geno
gene1   snp26   200     7.843116e-01    8.091162e-02    8.258911e-02
...
@end verbatim


@subsection Permutations

Genes having different numbers of SNPs in @emph{cis}, with different patterns of @url{https://en.wikipedia.org/wiki/Linkage_disequilibrium,linkage disequilibrium},
we implemented a permutation procedure @emph{at the gene level} (see Flutre @emph{et al}).
Such a procedure provides a p-value for each gene, required to control the FDR at the gene level,
hence allowing statements such as ``there are X genes having at least one eQTL at an FDR of x%''.

The option @option{--nperm} allows to specify how many permutations will be performed.
We recommend 10,000.
In practice, we permute the individual labels (not the sample labels).
As individuals can be present in several subgroups, we recommend to use @option{--permsep 1}
to preserve such correlation structure when doing a subgroup-by-subgroup analysis.
We can also specify the initialization of the random number generator with the option @option{--seed}
in order to be able to replicate the results exactly.

To speed-up the permutations, we also recommend to use the option @option{--trick 1}.
Indeed, when it is clear that there is no association between the given gene-SNP pair,
it is not necessary to perform 10,000 permutations, a much smaller number is enough,
and this option implements this adaptively for each gene-SNP pair.
It requires another random number generator, which also uses @option{--seed}.
The output file will contain the total number of permutations performed.
The option @option{--tricut} allows to tune the speed gain of the trick:
the smaller the faster (i.e. less permutations are performed when there is no association).
In our experience, using @option{--tricut 10} gives good results.

If we want to compare the two approaches (``separate'' versus ``joint'' analysis), we may want
to use the exact same permutations for both.
Yet we may also want to use the ``trick''.
Specifying @option{--trick 2} allows to do just that and is therefore recommended in this setting.

Finally, the option @option{--pbf} specifies which BF is used as a test statistic when @option{--analys join}.
The BF called ``BMA'' in Flutre @emph{et al} corresponds to @option{--pbf all},
and the BF called ``BMAlite'' corresponds to @option{--pbf gen-sin}.

However, permutations to obtain gene-level p-values are computationally intensive, perhaps prohibitively so for large datasets.
@xref{Tutorial}, in the end of the chapter, for efficient, yet powerful alternatives, namely the EBF and QBF procedures proposed in @url{http://arxiv.org/abs/1311.3981,this preprint} by Wen (2013).


@section Computing in parallel

For a small analysis, the command-line for @command{eqtlbma_bf} given in the tutorial is enough.
However, when dealing with many genes (20,000) and SNPs (5 millions),
we recommend to split the analysis in batches and launch them in parallel.
To simplify this and avoid the burden of creating new input files with genotypes and expression levels,
we can simply have several BED files with different subsets of genes (one per batch).

If we want 100 batches, we only need to split all the gene coordinates into 100 lists.
An FAQ entry below indicates how to do this easily.

Then, we can use the script @command{eqtlbma_bf_parallel.bash}.
After installation of the package, it should be in your PATH.
Otherwise it is in the directory @command{scripts/} of the package.

A typical command-line looks like this (works with @url{https://en.wikipedia.org/wiki/Oracle_Grid_Engine,Sun Grid Engine}):
@verbatim
qsub -cwd -j y -V -l h_vmem=2g -N job_eqtlbma -t 1-100 \
eqtlbma_bf_parallel.bash \
--p2b ~/bin/eqtlbma_bf \
--geneD lists_genes \
--snpD lists_snps \
--seedF list_seeds.txt.gz \
--geno list_genotypes.txt \
--scoord snp_coords.bed.gz \
--exp list_expressions.txt \
--out out_eqtlbma \
--analys join \
--covar list_covariates.txt \
--gridL grid_phi2_oma2_general.txt.gz \
--gridS grid_phi2_oma2_with-configs.txt.gz \
--bfs all
--error mvlr \
--nperm 10000 \
--trick 2 \
--pbf all
@end verbatim

Note that you can also use the option @option{--snp} if you want to analyse
only a subset of all SNPs per batch, e.g. only those in @emph{cis} of the genes
in the corresponding batch.
An FAQ entry shows how to find SNPs in @emph{cis} for each gene.

Another FAQ entry shows how to generate a file of seeds, 
to make each batch reproducible when doing permutations.

Once all jobs are finished, @pxref{Frequently asked questions} for details on how to concatenate all output files of a given kind,
for instance to have all ``_sumstats_<subgroup>.txt.gz'' batch files into a single file.

If the cluster doesn't work with SGE but with @url{https://en.wikipedia.org/wiki/Simple_Linux_Utility_for_Resource_Management,SLURM}, here is the equivalent command-line:
@verbatim
for i in $(seq -w 1 100); do echo $i; \
echo -e '#!/usr/bin/env bash\n'''eqtlbma_bf_parallel.bash \
--p2b ~/bin/eqtlbma_bf \
--geneD lists_genes \
--snpD lists_snps \
--seedF list_seeds.txt.gz \
--task ${i} \
--geno list_genotypes.txt \
--scoord snp_coords.bed.gz \
--exp list_expressions.txt \
--out out_eqtlbma \
--analys join \
--covar list_covariates.txt \
--gridL grid_phi2_oma2_general.txt \
--gridS grid_phi2_oma2_with-configs.txt \
--bfs all \
--error mvlr \
--nperm 10000 \
--trick 2 \
--pbf all'' \
| sbatch -J job_eqtlbma_bf -o stdout_eqtlbma_bf-perm-${i}.o%j \
--mem-per-cpu=10000; sleep 1; done
@end verbatim


@section Reading the outputs

@cindex outputs eqtlbma_bf

The program @command{eqtlbma_bf} creates several output files, all starting with 
the character string given to option @option{--out}, e.g. ``out_eqtlbma''
(remember to include the batch number when you parallelize yourselves,
otherwise @command{eqtlbma_bf_parallel.bash} does it automatically).
All output files contain a header line, which should make it easy to understand
what each file contains, as well as load each file into R.

If @option{--outss} is set and @option{--error mvlr} is not, one file is created per subgroup with some summary statistics.
They have the suffix ``_sumstats_<subgroup>.txt.gz''.
These summary statistics can be used to draw forest plots.
For steps 2 and 5, there will also be file(s) with the results of the permutations.
If @option{--permsep 1} was given, there will be one such file, with suffix ``_sepPermPvals.txt.gz''.
If @option{--permsep 2} was given, there will be one file per subgroup, with suffix ``_sepPermPvals_<subgroup>.txt.gz''.

One file will contain all the ``raw'' BFs, i.e. one per config per grid point, with suffix ``_l10abfs_raw.txt.gz''.
Such files are necessary to run the hierarchical model with @command{eqtlbma_hm} (see below).

If option @option{--outw} was given, there will also be one file containing all the BFs averaged over the grid, with suffix ``_l10abfs_avg-grids.txt.gz''.
Also, for steps 4 and 5, there will also be a file with the results of the permutations,
with suffix ``_jointPermPvals.txt.gz''.

@c=============================================================================

@node Fitting the hierarchical model
@chapter Fitting the hierarchical model

@cindex hierarchical model
@cindex eqtlbma_hm

The @command{eqtlbma_hm} program can take several options, available in the command line via @command{eqtlbma_hm -h}.

The option @option{--data} requires the input file with the Bayes factors,
typically the output file from @command{eqtlbma_bf} with suffix ``_l10abfs_raw.txt.gz''.
We can also give a file pattern (a @url{https://en.wikipedia.org/wiki/Glob_%28programming%29,glob}),
such as @option{--data "out_eqtlbma_[0-9][0-9][0-9]_l10abfs_raw.txt.gz"},
where ``@option{[0-9][0-9][0-9]}'' corresponds to the batch numbers (e.g. 001, 002, ..., 100).

The option @option{--nsubgrp} requires the number of subgroups, e.g. 3.

The option @option{--dim} requires the number of configurations to considered (i.e. the dimension of the latent space).
More specifically, it corresponds to the number of active configurations, e.g. 7 if there are 3 subgroups.

The option @option{--ngrid} requires the number of grid points to consider.
For instance, if we launched @command{eqtlbma_bf} with a ``small'' grid of 10 points (@math{\phi_l^2,\omega_l^2}),
we need to specify @option{--ngrid 10}.

The option @option{--out} requires the name of the output file, which will be gzipped.
The first lines start with a @url{https://en.wikipedia.org/wiki/Hashtag,hashtag} 
and correspond to the estimates of the hyperparameters,
along with their confidence intervals (if option @option{--getci} was given).
By default, these lines will be considered as comments by R and won't be loaded.
Then, if the option @option{--getbf} was given, the rest of the file contains averaged Bayes factors 
for each gene and gene-SNP pair.

The option @option{--init} can take an initialization file.
It should have 3 columns separated by a tabulation and one line per parameter.
The first column should contain the name of the parameter, such as ``config.1-2-3'' or ``grid.1''.
The second column should contain the value of the parameter.
The third column should contain a boolean, encoded as TRUE or FALSE, indicating if the parameter should be kept fixed or not.
Note that all parameters should be present in the file.

The option @option{--rand} can be used to randomly initialize the parameters at the beginning of the EM.
To make inference replicable, we can use the option @option{seed}.

The option @option{--tresh} can be given the threshold to terminate the EM algorithm.
That is, if the log-likelihood increases less than this threshold, the iterations stop.
The default value is set at 0.05.

The option @option{--maxit} can be used to fix the maximum number of iterations to be performed before stopping the EM algorithm.
It can be useful if @command{eqtlbma_hm} is executed on a computer cluster with a wall-time limit shorter than the running time of the EM algorithm.
For instance, if @command{eqtlbma_hm} is killed after 27 iterations, we can launch it a first time with @option{--maxit 25}; then extract the current estimates of the parameters and format them appropriately into an initialization file (@pxref{Frequently asked questions}); finally launch @command{eqtlbma_hm} a second time with @option{--init}.

The option @option{--msl} allows to use the SQUAREM procedure to speed-up the EM algorithm (Varadhan & Roland, 2008).
It was implemented thanks to the help of Chaoxing Dai.
By default, @option{--msl} is fixed at 1.0, which is interpreted as asking to use the classical EM algorithm
Otherwise, it is interpreted as the maximum value the step length can take (@math{\alpha} in the Varadhan & Roland article).
Based on a few experiments, we recommend setting @option{--msl} at 3.

In order to speed-up the computations greatly, the option @option{--thread} can be given
a number of threads (the code uses @url{https://en.wikipedia.org/wiki/OpenMP,OpenMP}).

If we want to fit the hierarchical model using only a pair of subgroups, we can use the option @option{--configs}.
For instance, among 3 subgroups, to only load the Bayes factors corresponding to subgroups 1 and 3,
we would do @option{--configs "1|3|1-3"}.

If we want to fit the hierarchical model according to the BMAlite approach, we can use the option@option{--keepgen}.
With @option{--keepgen}, the raw ABFs with "gen" in the "config" column of the output file from @command{eqtlbma_bf} will be kept, and those with gen-fix/gen-maxh will be ignored.
On the contrary, without @option{--keepgen} (i.e. the default), all raw ABFs with gen/gen-fix/gen-maxh in the "config" column will be ignored.

The option @option{--getci} can be set in order to compute and return 95% confidence intervals 
using the @url{https://en.wikipedia.org/wiki/Likelihood_function#Profile_likelihood,profile likelihood}.
However, this is not multi-threaded and can therefore be quite long.
Otherwise, only the maximum-likelihood estimates of the hyperparameters are returned.

By default, only the estimates of the hyperparameters (gene-level @math{\pi_0}, grid and configuration weights) 
are returned in the output file.
We can use option @option{--getbf} in order to also get the Bayes factor for each gene and each gene-SNP pair, 
as well as the BF for each configuration, which can take a lot of time to compute and result in a big file.
We would hence surely prefer to use the @command{eqtlbma_avg_bfs} program (see below) which offers more flexibility 
about which quantities to compute (averaged Bayes factors, various posteriors).

The gene-level @math{\pi_0} (the probability for a gene to have no eQTL) 
is hard to estimate accurately with the EM algorithm, 
therefore it can be useful to estimate it by another method (e.g. permutations, EBF/QBF procedure)
and set it manually to see how it impacts the estimates of the other hyperparameters.
We can easily do it using option @option{--pi0}, meaning that pi0 won't be updated by the EM algorithm.
Another way is to use a file with @option{--init}, but in that case all other parameters should also be present in the file.

Finally, the command-line will typically look like this:
@verbatim
eqtlbma_hm \
--data "out_eqtlbma_*_l10abfs_raw.txt.gz" \
--nsubgrp 3 \
--dim 7 \
--ngrid 10 \
--out out_eqtlbma_hm.txt.gz \
--thread 4
@end verbatim

After launching the @command{eqtlbma_hm} program, we can follow the EM iterating on stdout.

Then, if option @option{--getbf} was not given, we can use the @command{eqtlbma_avg_bfs} program 
to compute the final quantities of interest, e.g. posteriors.

@c=============================================================================

@node Computing the posteriors
@chapter Computing the posteriors

@cindex posteriors
@cindex eqtlbma_avg_bfs

The @command{eqtlbma_avg_bfs} program can take several options, available in the command line via @command{eqtlbma_avg_bfs -h}.

The option @option{--in} requires the input file with the Bayes factors,
typically the output file from @command{eqtlbma_bf} with suffix ``_l10abfs_raw.txt.gz''.
We can also give a file pattern (a @url{https://en.wikipedia.org/wiki/Glob_%28programming%29,glob}),
such as @option{--data "out_eqtlbma_[0-9][0-9][0-9]_l10abfs_raw.txt.gz"},
where ``@option{[0-9][0-9][0-9]}'' corresponds to the batch numbers (e.g. 001, 002, ..., 100).

The option @command{--gwts} requires the path to a file containing the grid weights.
There should be one value per line.
For instance, with the default grid in file ``grid_phi2_oma2_with-configs.txt.gz'' 
as generated by the R code in the FAQ, there are 10 lines.
@xref{Frequently asked questions} to know how to extract the grid weights from the output of @command{eqtlbma_hm}.

If you want to only keep a subset of the Bayes factors, for instance only those corresponding to lines 1, 3 and 5 of the grid,
you can use the option @command{--gtk}, such as @option{--gtk 1+3+5}.

The option @command{--nsubgrp} requires the number of subgroups, and the option @command{--dim} requires the dimension of the model, that is the number of active configurations (7 if there are 3 subgroups).

The option @command{--cwts} requires the path to a file containing the configuration weights.
This file should have two columns, the identifier of the configuration and its probability.
There should then be one configuration per line.
In the end, the file should look like this:
@verbatim
1       0.13
2       0.19
1-2     0.68
@end verbatim
@xref{Frequently asked questions} to know how to extract the configuration weights from the output of @command{eqtlbma_hm}.

The option @option{--save} is used to indicate which quantity(ies) should be saved in the output file.
Using @option{--save bf} means that only Bayes factors will be saved,
@option{--save post} means that only posteriors will be saved,
and @option{--save bf+post} means both.
Note that saving the posteriors also requires specifying the options @option{--pi0} and @option{--post} (see below).

The option @option{--pi0} requires the value of the probability for a gene to have no eQTL in any subgroup.
If not provided, Bayes factors will be saved instead of posteriors.
As @math{\pi_0} is hard to estimate accurately with the EM algorithm,
it can be useful to estimate it by another method (e.g. permutations, EBF/QBF procedure).

The option @option{--post} requires the kind(s) of posteriors to save.
Using @option{--post a} corresponds to the posterior for a gene to have at least one eQTL in at least one subgroup,
@option{--post b} corresponds to the posterior that the SNP is ''the'' eQTL for the gene (i.e. ``eQTN''), in at least one subgroup, given that the gene has exactly one eQTL and assuming all cis SNPs are equally likely;
@option{--post c} corresponds to the posterior that the SNP is 'an' eQTL for the gene, in at least one subgroup, given that the gene contains at least one eQTL and that the SNPs are independent;
and @option{--post d} corresponds to the posterior that the SNP is an eQTL in subgroup s, given that it is ``the'' eQTL for the gene (i.e. the configurations are marginalized).

The option @option{--gene} requires the path to a file with a subset of gene(s) to keep.
There should be one gene per line.

The option @option{--snp} requires the path to a file with a subset of SNP(s) to keep.
There should be one SNP per line.
Caution about this option because, as not all cis SNPs are kept, this will change gene-level Bayes factors and posteriors.

The option @option{--gene-snp} requires the path to a file with a subset of gene-SNP pair(s) to keep.
There should be two columns, the first for the gene and the second for the SNP.
As for @option{--snp}, as not all cis SNPs are kept, this will change gene-level Bayes factors and posteriors.

The option @option{--bestsnp} requires the kind of best SNP(s) to save.
The default, @option{--bestsnp 0} means that all cis SNPs will be saved.
Using @option{--bestsnp 1} means only the best SNP is saved (pick one if tie), based on the proba for a SNP to be ``the'' eQTL.
Using option @option{--bestsnp 2} means that, possibly several, best SNPs are reported so that the sum of their proba to be ``the'' eQTL just exceeds 0.95.

The option @option{--bestdim} is used to report the best configuration per SNP, as well as its Bayes factor and/or posterior,
whereas the option @option{--alldim} reports the Bayes factors and/or posteriors of all configurations (caution, this can be a lot).

The option @option{--thread} requires the number of threads to use (default is 1).

Finally, the command-line will typically look like this:
@verbatim
eqtlbma_avg_bfs \
--in "out_eqtlbma_*_l10abfs_raw.txt.gz" \
--gwts grid_weights.txt \
--nsubgrp 3 \
--dim 7 \
--cwts config_weights.txt \
--save post \
--pi0 0.783629 \
--post a+b+c+d \
--bestdim \
--alldim \
--out out_eqtlbma_avg_bfs.txt.gz \
--thread 4
@end verbatim

@c=============================================================================

@node For developers
@chapter For developers

@cindex Developers

The eQtlBma package is freely available under the GNU General Public License version 3 or later (GPL-3+).
The code is versioned with git and the official repository is available on @url{http://github.com/timflutre/eqtlbma,Github}, 
so you can fork it and let us know of any pull request.
The core of the package is written in C++, but parts of it are also in R and bash.
In all languages, we are using the @url{https://en.wikipedia.org/wiki/CamelCase,camel case} notation with an uppercase first letter for classes and a lowercase first letter for methods, functions and variables.
Functional tests are implemented, even though, of course, unitary tests would be preferable (see the TODO file).
Importantly, variable and function name are chosen so as to be as explicit as possible!
For those using @url{https://www.gnu.org/software/emacs/,Emacs}, here is the configuration:

@verbatim
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
(setq c-default-style "bsd"
      c-basic-offset 2
      tab-width 2
      indent-tabs-mode t)
(setq sh-basic-offset 2
      sh-indentation 2)
@end verbatim

In terms of versioning, the eQtlBma package follows the @url{http://semver.org/,Semantic Versioning} guidelines.
For each release, a git tag is created, and then pushed to GitHub.

@c=============================================================================

@node Frequently asked questions
@chapter Frequently asked questions

@cindex FAQ

@itemize

@item
@strong{How do I cite this package?}

Flutre T, Wen X, Pritchard J, Stephens M (2013) A Statistical Framework for Joint eQTL Analysis in Multiple Tissues. PLoS Genet 9(5): e1003486. doi:10.1371/journal.pgen.1003486

This article is freely available @url{http://dx.doi.org/10.1371/journal.pgen.1003486,online}.

@sp 1

@item
@strong{Who funded this work?}

As described in @url{http://dx.doi.org/10.1371/journal.pgen.1003486,Flutre et al.}, Jonathan Pritchard, Matthew Stehens and Xiaoquan Wen were supported by @url{http://www.nih.gov/,NIH} grant @url{http://projectreporter.nih.gov/project_info_description.cfm?aid=8509199&icde=18936720,MH090951}. Timoth@'ee Flutre was also supported by the Institut National de la Recherche Agronomique (@url{http://www.inra.fr/en,INRA}) as ASC.

@sp 1

@item
@strong{Who contributed to this package?}

Timoth@'ee Flutre designed the package, wrote the major part of its code in C++, wrote the functional tests using R and bash, as well as the documentation using TexInfo.
Xiaoquan (William) Wen wrote the C++ class that computes the multivariate approximate Bayes Factor, which was integrated into the package by T. Flutre without any change, as well as the C++ functions of the EM algorithm, which were also integrated into the package by T. Flutre, but this time with substantial refactoring.

The SQUAREM procedure was implemented thanks to the help of Chaoxing Dai.

Gao Wang fixed a bug when filtering SNPs with missing genotypes when provided in the ``custom'' format.

Sarah Urbut provided useful feedback at various time points.

And last, but not least, such a package would not exist without the availability of several free softwares, notably the GNU Scientific Library (GSL).

@sp 1

@item
@strong{How do I make the file(s) for the grid(s)?}

See the function @option{makeGrid} in the file @command{scripts/utils_eqtlbma.R}.
A typical code would look like this:
@verbatim
gridL <- makeGrid("general")
write.table(x=gridL, file=gzfile("grid_phi2_oma2_general.txt.gz"),
            quote=FALSE, row.names=FALSE, col.names=FALSE)
gridS <- makeGrid("configs")
write.table(x=gridS, file=gzfile("grid_phi2_oma2_with-configs.txt.gz"),
            quote=FALSE, row.names=FALSE, col.names=FALSE)
@end verbatim

@sp 1

@item
@strong{How do I transform my phenotypes beforehand into the quantiles of a standard Normal?}

See the function @option{transformGeneExpInStdNormal} in the file @command{scripts/utils_eqtlbma.R}.
Ties can be broken randomly (particularly useful with RNA-seq).

@sp 1

@item
@strong{How do I make the tabix index for the BED file with SNP coordinates?}

Start by installing the @url{https://github.com/samtools/tabix,TABIX} package.
Then sort the BED file and compress it with the @command{bgzip} program (part of the TABIX package).
Finally, make the index with the @command{tabix} program.
All this can be done with the following commands:

@verbatim
cat snp_coords.bed | sort -k1,1V -k2,2g | bgzip > snp_coords.bed.gz
tabix -p bed snp_coords.bed.gz
@end verbatim

The option @option{-V,--version-sort} of GNU sort allows to sort chromosome names in alpha-numeric order, i.e. ``chr10'' after ``chr2''.
It is available at least in version 8.17 of @url{https://www.gnu.org/software/coreutils/, GNU coreutils} or later.

@sp 1

@item
@strong{How do I split the BED file of gene coordinates in 100 batches?}

Using GNU tools and assuming the coordinates are in a file named ``gene_coords.bed.gz'':

@verbatim
nbBatches="100"; rm -rf lists_genes; mkdir lists_genes; cd lists_genes; \
zcat ../gene_coords.bed.gz | split \
-l $(echo "scale=0; $(zcat ../gene_coords.bed.gz | wc -l)/${nbBatches}" | bc -l) \
--suffix-length=3 --numeric-suffixes=1 --additional-suffix=.bed \
--filter='gzip > $FILE.gz' - list_genes_; cd ..
@end verbatim

This will create approximately 100 files in a directory, such as ``lists_genes/list_genes_001.bed.gz'', ``lists_genes/list_genes_002.bed.gz'', etc.

@sp 1

@item
@strong{How do I get a file with SNPs in @emph{cis} for each batch of genes?}

Using @url{http://bedtools.readthedocs.org/en/latest/,BEDTools}, it's quite easy.
As it can take some time, we can use @url{http://www.gnu.org/software/parallel/,GNU parallel} to speed this up:

@verbatim
rm -rf lists_snps; mkdir lists_snps; \
seq -w 1 $(ls lists_genes/* | wc -l) | \
parallel 'i={}; bedtools window -w 100000 \
-a lists_genes/list_genes_${i}.bed.gz \
-b snp_coords.bed.gz | \
cut -f10 | sort -V | uniq | gzip > lists_snps/list_snps_${i}.txt.gz'
@end verbatim

Each SNP file contains the identifiers (e.g. rs number) of the SNPs in cis of the genes in the corresponding batch.
Change the "100000" into "1000000" if you want a 1Mb radius instead of a 100Kb radius for the @emph{cis} window.
Note also that, to have the @emph{cis} region centered on the TSS only (i.e. neglecting the TES), 
you will first have to modify the file "gene_coords.bed.gz":

@verbatim
zcat gene_coords.bed.gz \
| awk 'BEGIN{OFS="\t"} \
{printf "%s\t%s\t%s", $1,$2,$2+1; \
for(i=4;i<=NF;++i)printf "\t%s", $i; printf "\n"}' \
| gzip > gene_coords_TSS.bed.gz
@end verbatim

@sp 1

@item
@strong{How do I make the file of seeds when using eqtlbma_bf_parallel.bash?}

Before launching @command{eqtlbma_bf_parallel.bash} to do permutations, 
use the following command-line (requires R):

@verbatim
nbSeeds=$(ls lists_genes/* | wc -l); \
echo "set.seed(1859); x <- sample.int(n=1000000, size=${nbSeeds}); \
write(x, gzfile(\"list_seeds.txt.gz\"), 1)" \
| R --vanilla --quiet
@end verbatim

@sp 1

@item
@strong{How do I easily concatenate the output files from all batches?}

When launching @command{eqtlbma_bf} in parallel, you will get several output files for each batch.
For a given kind of output files, for instance the summary statistics of a given subgroup,
it may be easier to deal with a single file.
Below are simple bash commands to concatenate all batch files of a same kind into a single file and compress it:

@verbatim
sbgrp="Tissue3"; i=0; \
ls out_eqtlbma_[0-9][0-9][0-9]_sumstats_${sbgrp}.txt.gz | while read f; do \
let i=i+1; echo $i; \
if [ $i -eq "1" ]; then zcat $f > out_eqtlbma_sumstats_${sbgrp}.txt; \
else zcat $f | sed 1d >> out_eqtlbma_sumstats_${sbgrp}.txt; fi; done
gzip out_eqtlbma_sumstats_${sbgrp}.txt
@end verbatim

You will have to adapt this command for the other kinds of output files.

@sp 1

@item
@strong{How do I extract the grid weights from eqtlbma_hm's output?}

Before using @command{eqtlbma_avg_bfs}, use the following command-line:
@verbatim
zcat out_eqtlbma_hm.txt.gz | grep "#grid" | cut -f2 > grid_weights.txt
@end verbatim

@sp 1

@item
@strong{How do I extract the configuration weights from eqtlbma_hm's output?}

Before using @command{eqtlbma_avg_bfs}, use the following command-line:
@verbatim
zcat out_eqtlbma_hm.txt.gz | grep "#config" \
| awk '{split($1,a,"."); print a[2]"\t"$2}' > config_weights.txt
@end verbatim

@sp 1

@item
@strong{How do I format the parameter estimates from eqtlbma_hm's output to feed --init?}

Use the following command-line:
@verbatim
zcat out_eqtlbma_hm.txt.gz | grep "#" | sed 's/#//g' | sed 1d \
| cut -f1,2,5 > init_hm.txt
@end verbatim

@sp 1

@item
@strong{How do I extract ABFs for a subset of genes after eqtlbma_bf?}

First, you have to write in a file the list of genes you are interested in.
This file, below assumed to be called "list_genes_tokeep.txt", should have a single column and a single gene identifier per line.

Then, assuming that you ran eqtlbma_bf in parallel, use the following command-line to (1) list all ABF files, and then, for each of them, (2) retrieve the file prefix, (3) extract the genes of interest into another file, and (4) compress it:
@verbatim
ls *_l10abfs_raw.txt.gz | while read f; do \
  echo $f; f2="${f%.txt.*}"; echo $f2; \
  rm -f ${f2}_filter.txt; \
  zcat $f | head -1 > ${f2}_filter.txt; \
  zcat $f | sed 1d | grep -f list_genes_tokeep.txt >> ${f2}_filter.txt;
  gzip ${f2}_filter.txt
done
@end verbatim

As it can take some time, we can use @url{http://www.gnu.org/software/parallel/,GNU parallel} to speed this up:
@verbatim
ls *_l10abfs_raw.txt.gz | \
parallel 'f={}; f2="${f%.txt.*}"; rm -f ${f2}_filter2.txt; \
zcat $f | head -1 > ${f2}_filter2.txt; \
zcat $f | sed 1d | grep -f list_genes_tokeep.txt >> ${f2}_filter2.txt;
gzip ${f2}_filter2.txt'
@end verbatim

@sp 1

@item
@strong{Is this packaged tested?}

We implemented some R code in order to perform @url{https://en.wikipedia.org/wiki/Functional_testing,functional tests} on @command{eqtlbma_bf} and @command{eqtlbma_hm}.
Launching them is automatized via @option{make check} (requires R >= 2.15).

You can also find in the @command{src/} directory the code used to simulate data as in Flutre @emph{et al} (2013).
To compile it, enter into the @command{src/} directory and run @command{grep "g++" simul_flutre_et_al.cpp} 
to see how to do it.
As usual, a help message is available with the option @command{-h}.

If you find a bug, please don't hesitate to contact us, thanks in advance!

@end itemize


@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@node Index
@unnumbered Index

@printindex cp

@bye
